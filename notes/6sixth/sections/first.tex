\newpage
\chapter{Death locks.}

\textit{Bloqueo mutuo}\\
Es un evento en el que dos o mas procesos se bloquean en espera de dos o mas recursos de modo que no pueden prograsar independientemente del tiempo que pase..\\
Es como cuando dos camiones quieren dar vuelta y se bloquean mutuamente.\\

Tenemos un deadlock solo cuando se cumplen las siguientes 4 condiciones:
\begin{enumerate}
	\item Exclusi\'{o}n mutua. Los procesos reclaman control exclusivo de los procesos.
	\item Hold \& Wait. Los procesos mantienen las asignaciones a los recursos en lo que esperan por los demas recursos que necesitan.
	\item Non-preemption. La asignacion de los recursos no puede ser revocada.
	\item Espera circular. Se genera una secuenia de procesos en espera de recursos asignados a otros procesos.
\end{enumerate}
Estas condiciones sirven para saber cuando es un bloqueo 'normal' o cuando es un deathlock

\section{Mecanismos de detecci\'{o}n}

\subsection{Algoritmo del avestruz}
En sistemas operativos y no implementa ning\'{u}n mecanismo dejando a cargo del usuario el identificar bloqueos y tomar las medidas correctivas.\\
\subsection{Modelo gr\'{a}fico.}
En este se dibuja un grafo en el que se pueden buscar los ciclos.\\
\subsection{An\'{a}lisis matricial.}
Se pueden construir matrices que representen los grafos de asignacion de recuros que se operan para detectar ciclos.\\
Es costos en CPU y solamente permite detectar.
\subsection{An\'{a}lisis de regiones de riesgo.}
Se define como regi\'{o}n de riesgo el estado de una matriz de asignacion de recursos inmediata anterior al deathlock y se niegan las agignaciones de recursos que llevan a regiones de riesgo.\\

\section{Prevencion de los deathlocks.}
Para estos, basta negar alguna condicion del DL.

\subsection{Exclusion mutua.} Reemplazar recursos preemtive por non-preemtive.\\
\subsection{Hold \& Wait} Podemos agrupoar todos los recursos y asignarlos en una sola operacio\'{o}n\\
\subsection{Noon-preemtive} Son operaciones que 'guardan' el estado inciial de los recursos y en caso de problemas preemtive, regeneran \'{e}ste.\\

\section{Comunicaci\'{o}n entre procesos.}

\subsection{Se\~{n}ales.} Estas permiten a un proceso de la jerarquia enviar una se\~{n}al con un valor entero que interrumpe el flujo de la aplicaci\'{o}n para ejecutar la funci\'{o}n definida como handler.\\

\subsection{Pipes} Todos los procesos se asocian a tres streams.
\begin{enumerate}
	\item \textit{STDIN} - Entrada est\'{a}ndar
	\item \textit{STDOUT} - Salida est\'{a}ndar.
	\item \textit{STDERR} - Salida  de errores.
\end{enumerate}
\paragraph{Proceso1 \textit{>} file.txt} Escribe la salida STDOUT a un archivo file.txt (sobreescribe el archivo)\\
\paragraph{Proceso1 \textit{>>} file.txt} Escribe la salida STDOUT a un archivo (append)\\
\paragraph{Proceso1 \textit{|} Proceso2} Asigna STDOUT de Proceso1 al STDIN de Proceso2\\
\paragraph{Proceso1 \textit{2>} file.txt} Escribe la salida STDERR de Proceso1 a file.txt\\

\chapter{Administraci\'{o}n de la memoria.}
